# Локальна пам’ять потоку

Клас з ключовим словом `static` дозволяє декларувати об'єкти, які ініціюються
лише раз. Якщо та сама команда виконується вдруге, ініціалізація буде
пропущена. Кожен потік отримає свій власний об'єкт `static`
(*ЛПП - локальна пам'ять потоку*), що завадить йому ідентифікувати
або модифікувати інший об'єкт потоку `static` – у той же час, ім'я
змінної залишається незмінним. Таким чином, `static` дозволяє
декларувати об'єкт зі збереженням стану, що є важливим для
*поточного* потоку. 

Це відрізняється від тих же C/C++ і Java, де `static` відіграє
глобальну роль при застосуванні, тягнучи за собою проблеми
синхронізації у багатопоточності.

Значення, присвоєне до змінної `static` повинно бути визначене під час
компіляції. Воно не повинно мати залежностей під час реалізації!
Необхідно форматувати змінні `static` під час реалізації,
використовуючи одноразовий конструктор `static this()` для структур,
класів і модулів. 

    static int b = 42;
    // b ініціюється лише раз!
    // При запуску з різних потоків
    // кожен b буде мати "власну" b
    // без зовнішнього втручання
    // інших потоків.

Крім того, для декларування «класичної» глобальної змінної, яку може
модифікувати кожен потік, необхідно використати клас пам’яті
`__gshared`, який є еквівалентом класу `static` у мові програмування С. 
Таке здавалося б жахливе ім'я заохочує використовувати цей клас якомога
рідше.

    __gshared int b = 50;
    // Також ініціюється лише раз!
    // Дійсно важливий b,
    // може читатися і модифікуватись
    // (небезпечно) кожним потоком!

### Поглиблення

- [Локальна пам'ять потоку у Wikipedia](https://en.wikipedia.org/wiki/Thread-local_storage)

## {SourceCode}

```d
import std.concurrency : spawn, thisTid;

void worker(bool firstTime)
{
    import std.stdio : writeln;
    // theStatic є глобальним лише для
    // існуючого потоку. Жодний інший
    // потік не матиме доступу до нього.
    // Зверніть увагу, що ініціалізація
    // відбувається лише першого разу,
    // коли виконується даний рядок.
    static int threadState = 0;
    writeln("Потік ", thisTid,
        ": Мій стан = ", threadState++);
    if (firstTime)
        worker(false);
}

void main()
{
    // Створюємо 5 потоків, де кожен
    // викличе метод worker(true,i).
    for (size_t i = 0; i < 5; ++i) {
        spawn(&worker, true);
    }
}
```
