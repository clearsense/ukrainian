# Зрiзи

Зрiзи - це об'єкти типу `T[]` для будь-якого заданого типу `Т`.
Зрiз надає вид на підмножину масиву
значень `Т` - або просто вказує на весь масив.
**Зрiзи і динамічні масиви - це одно і то-ж.**

Зріз складається з двох елементів - покажчик на початковий елемент та
довжини зрізу:

    T* ptr;
    size_t length; // беззнакове 32-бiтне на 32-бiт платформах, беззнакове 64-бiтне на 64-бiт платформах.

Коли створюється новий динамічний масив, для зрiзу видiляється новий шматочок пам'ятi :

    auto arr = new int[5];
    assert(arr.length == 5); // пам'ять на яку посилається arr.ptr

Сiнтаксiс `[start..end]` визначає суб-зріз існуючого
зрізу, який містить всі елементи від `start`-у до елементу _перед_` end`:

    auto newArr = arr[1 .. 4]; // iндекс 4 не включеный
    assert(newArr.length == 3);
    newArr[0] = 10; // змiнює newArr[0] який спiвпвдвє з arr[1]

Зрiзи створюють новий погляд на існуючу пам'ять. Вони *не є створюють*
нову копія. Якщо жоден зрiз більше не містить посилання на пам'ять  - або на її
частину - вона буде звільнена збирачем сміття.

Використовуючи зрізи можна писати дуже ефективний код, наприклад, парсери
які просто працюють на одному блоці пам'яті просто посилаючись на неї за допомогою зрiзiв -
без необхідності виділення нових блоків пам'яті.

As seen in the previous section the `[$]` expression is a shorthand form for
`arr.length`. Hence `arr[$]` indexes the element one past the slice's end and
thus would generate a `RangeError` (if bounds-checking hasn't been disabled).

Як було показано в попередньому розділі вираз `[$]` є скороченою формою
для `arr.length`. Отже, `arr[$]` посилається на перший елемент за кінецем зрізу і
таким чином, буде генерувати `RangeError` (якщо не була відключена перавiрка кордону зрiзiв).

### Додатково

- [ВВедення у зрiзи в D](http://dlang.org/d-array-article.html)
- [Зрiзи в _Programming in D_](http://ddili.org/ders/d.en/slices.html)

## {SourceCode}

```d
import std.stdio;

/**
Рекурсивно розраховує мінімум всіх значень
в зрізі. Для кожного рекурсивного
виклику суб-зріз береться таким чином, що ми не
створюємо копію і не робимо будь-яких призначень.
*/
int minimum(int[] slice)
{
    assert(slice.length > 0);
    if (slice.length == 1)
        return slice[0];
    auto otherMin = minimum(slice[1 .. $]);
    return slice[0] < otherMin ?
        slice[0] : otherMin;
}

void main()
{
    int[] test = [ 3, 9, 11, 7, 2, 76, 90, 6 ];
    auto min = minimum(test);
    writefln("The minimum of %s is %d",
        test, min);
    assert(min == 2);
}
```
