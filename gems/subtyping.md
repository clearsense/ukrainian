# Створення підтипів

`Структура` не може успадковуватись від інших `структур`. Але мова D
забезпечує для цього обмеженого типу інші чудові засоби, які допомагають
розширити їх функціональність: **створення підтипу**.

Тип структури може бути визначеним одним зі своїх членів, як
`alias this`:

    struct SafeInt {
        private int theInt;
        alias theInt this;
    }

Будь-яка функція або операція над `SafeInt`, яка не зможе обробити цей
тип, буде спрямована до члена `alias this`. Тоді ззовні `SafeInt` буде
виглядати, як звичайне ціле число.

Це дозволяє розширити інші типи новими функціональними можливостями,
але з нульовими витратами з точки зору пам'яті або виконання.
Компілятор намагається чинити правильно, коли звертається до члена
`alias this`.

`alias this` працює також з класами.

## {SourceCode}

```d
import std.stdio : writeln;

struct Vector3 {
    private double[3] vec;
    alias vec this;

    double dot(Vector3 rhs) {
        return vec[0]*rhs.vec[0] +
          vec[1]*rhs.vec[1] + vec[2]*rhs.vec[2];
    }
}

void main()
{
    Vector3 vec;
    // ми в основному спілкуємось
    // тут з double[].
    vec = [ 0.0, 1.0, 0.0 ];
    assert(vec.length == 3);
    assert(vec[$ - 1] == 0.0);

    auto vec2 = Vector3([1.0,0.0,0.0]);
    // але ця функціональність
    // була розширена!
    writeln("vec dot vec2 = ", vec.dot(vec2));
}
```
